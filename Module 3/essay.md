# Эссе: Концепция Event Loop

Когда я думаю о **threading** и **asyncio**, мне проще всего представить это как кухню.

В случае с **threading** на кухне работает **много поваров**.
Каждый из них отвечает за своё блюдо - один варит суп, другой жарит мясо, третий режет овощи.
Они работают параллельно, и если один ждёт, пока закипит вода, другие продолжают что-то делать.
Но у такого подхода есть минус - чем больше поваров, тем больше места и ресурсов нужно.
Если на кухню позвать 1000 поваров, она просто превратится в хаос.

А вот **asyncio** - это как **один повар-ниндзя**.
Он не стоит без дела и не ждёт, пока закипит суп.
Он ставит сразу несколько кастрюль и постоянно между ними переключается - проверяет, где закипело, где нужно помешать, а где можно подождать ещё немного.
Он делает всё последовательно, но настолько быстро и умно, что кажется будто он работает одновременно на всех фронтах.

Так и в Python: **Event Loop** - это “повар”, который управляет задачами.
Он не создаёт сотни потоков, а просто переключается между задачами, когда одна из них чего-то ждёт, например, ответа от сервера или чтения файла.
Из-за этого `asyncio` может выполнять 1000 операций одновременно, оставаясь при этом **однопоточным**.

В итоге получается, что **threading** - это "много поваров и много ресурсов",
а **asyncio** - "один повар-ниндзя, но с тысячей кастрюль".
Первое хорошо, когда нужно использовать процессор на максимум, а второе, когда программа в основном ждёт внешние ответы.
Asyncio - это про эффективность и умение не терять время зря.
